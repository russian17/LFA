# Regular Grammars & Finite Automata

### Course: Formal Languages & Finite Automata
### Author: Cuzmin Simion

----

## Theory
If needed, but it should be written by the author in her/his words.


## Objectives:

1. Discover what a language is and what it needs to have in order to be considered a formal one;

2. Provide the initial setup for the evolving project that you will work on during this semester. You can deal with each laboratory work as a separate task or project to demonstrate your understanding of the given themes, but you also can deal with labs as stages of making your own big solution, your own project. Do the following:

    a. Create GitHub repository to deal with storing and updating your project;

    b. Choose a programming language. Pick one that will be easiest for dealing with your tasks, you need to learn how to solve the problem itself, not everything around the problem (like setting up the project, launching it correctly and etc.);

    c. Store reports separately in a way to make verification of your work simpler (duh)

3. According to your variant number, get the grammar definition and do the following:

    a. Implement a type/class for your grammar;

    b. Add one function that would generate 5 valid strings from the language expressed by your given grammar;

    c. Implement some functionality that would convert and object of type Grammar to one of type Finite Automaton;

    d. For the Finite Automaton, please add a method that checks if an input string can be obtained via the state transition from it;


## Implementation description

1. Grammar Class:
  The Grammar class represents a context-free grammar (CFG).
  Attributes:
    VN: Set of non-terminal symbols.
    VT: Set of terminal symbols.
    P: Production rules, where each non-terminal symbol maps to a list of production rules.
    S: Start symbol.
  Methods:
    generateValidStrings(count): Generates valid strings based on the grammar rules. It recursively generates strings by replacing non-terminals with their corresponding productions until terminal symbols are reached.
    toFiniteAutomaton(): Converts the grammar to an equivalent finite automaton (FA). It constructs the states, alphabet, transition function, initial state, and set of final states of the FA based on the grammar rules.
2. FiniteAutomaton Class:
  The FiniteAutomaton class represents a finite automaton (FA).
  Attributes:
    Q: Set of states.
    Sigma: Alphabet (set of symbols).
    Delta: Transition function, which maps a state and a symbol to a set of states.
    q0: Initial state.
    F: Set of final states.
  Methods:
    stringBelongToLanguage(w): Determines whether a given string w belongs to the language accepted by the automaton. It simulates the state transitions based on the input string and returns True if the final state after processing the string is one of the final states, otherwise returns False.



## Results


## Conclusions
